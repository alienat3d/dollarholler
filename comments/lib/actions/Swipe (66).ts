import { spring } from 'svelte/motion';

interface SwipeProps {}

// * 66.0 Здесь мы рассмотрим создание кастомной функции для добавления возможности свайпать компоненты на мобильных устройствах в сторону, открывая под ними меню для дальнейших манипуляций ими (например, как контекстное меню и кнопка "три точки" на больших экранах). Вспомним, что каждый action принимает "node" первым параметром (собственно это элемент в вёрстке, на котором он применяется).
// Go to [src\routes\(dashboard)\invoices\InvoiceRow.svelte]
// 66.2 Вторым параметром будет "params", это опции, которые нам нужны для работы этой функции. Ему мы напишем свой собственный interface выше.
// 66.3 Также вспомним, что каждый action может вернуть "update & destroy" спец. методы action'а, которые выполняются, когда элемент обновляется и убирается из вёрстки соответственно.
// 66.4 Итак, пока работаем с событиями мышки, т.к. разработка у нас на компьютере, распишем функционал: 1) нам нужна функция, которая будет фиксировать действие пользователя (прикосновение к тачскрину\нажатие кнопки мыши); 2) нам нужна функция, что фиксирует передвижение\свайп (с пальцем на экране, мышки с зажатой клавишей); 3) и наконец функция, что фиксирует, что палец убран с экрана\кнопка мыши отжата.
// 66.5 Важно не забывать также удалять слушатели событий, чтобы они не размножались и не засоряли память на устройстве пользователя.
// 66.6.0 Затем мы создадим переменную "x", которая будет фиксировать позицию мыши\пальца по горизонтали. А также константу "coordinates", которая будет содержать функцию "spring", которая есть в пакете "svelte/motion" и помогает работать с координатами из хранилища. В отличии от функции "tweened" у "spring" есть дополнительные настройки, которые помогут сделать отклик на перемещения мышки или пальца по экрану более естественным (более подробно в доке Svelte).
// 66.6.1 Внутрь "spring" мы помещаем объект, где пропишем настройки: координаты на 0 по Х и Y оси, stiffness ("подвижность/лёгкость отклика") на 0.2, damping ("замедление") на 0.4
// 66.6.2 Далее мы подпишемся на созданное хранилище с координатами и настройками с помощью метода "subscribe". Внутрь поместим само хранилище (его можно назвать как угодно). Нам нужно менять положение элемента в зависимости от координат по оси X с помощью CSS, поэтому через style обратимся к transform translate3d (т.к. он чуть более производителен, чем обычный "translate" и использует GPU девайса, а не просто CPU). И здесь нам на самом деле нужен лишь первый параметр, что соответствует X, а Y и Z оставим 0.
// 66.7 Теперь нам нужно обновлять хранилище с координатами всякий раз, когда мышка двигается. Переходим снова к функции "handleMouseMove" и здесь нам нужно находить дельту (разницу от первоначального значения). Итак нам нужно зафиксировать первоначальное значение в функции "handleMouseDown" присвоив переменной "x" значение event.clientX, чтобы получить значение на координатной оси Х, где пользователь нажал на кнопку. Далее создадим константу "dx" (Delta X) в функции "handleMouseMove", где будем считать дельту по оси Х. И мы будем вычитать текущее значение clientX из первоначального в переменной "х".
// 66.8 Теперь, когда дельта находится, мы будем перезаписывать значение "x" текущим значением clientX внутри "handleMouseMove" и передавать его в хранилище coordinates на обновление с помощью "update".
// 66.9.0 Отлично, теперь мы можем двигать инвойсы по экрану, но это не совсем то, что нам было нужно. А нужно нам, чтобы по движению влево они двигались до определённой точки, а по движению вправо возвращались на то место, где было вначале. Чтобы это осуществить нам нужно определять в какую сторону двигает пользователь инвойсы и для этого нам понадобится ещё одна переменная, которая будет хранить общие движения элемента.
// 66.9.1 Создадим "startingX" переменную и будем в неё записывать координаты по оси X в функции "handleMouseMove". Затем перейдём к функции "handleMouseUp", чтобы определить координаты, где пользователь отпустил кнопку\убрал палец с экрана и создадим для этого переменную "endingX". А также нам понадобится функция moveCardOver для расчёта движения, куда передадим данные из "endingX". А дальше вычислим движение простым вычитанием значения "endingX" из "startingX". Затем в условии скажем, что если значение "movement" > 20 пикселей (причина почему 20 - это сделает свайп чуточку менее чувствительным, чтобы предотвратить случайное срабатывание).
// 66.9.2 Затем создадим переменные "leftSnapX" и "rightSnapX" для указания границ, за которые инвойсы не должны уезжать. Значение "rightSnapX" указать легко, т.к. это будет 0, т.е. изначальная координата до какого-то действия.
// 66.9.3 Значение "leftSnapX" должно быть около 95% ухода инвойса за границу экрана, чтобы не закрывать собой кнопки меню и в то же время быть легко доступным, чтобы свайпом вернуть его на место. Нам нужно определять какое значение у 95%, т.к. у разных ширин экрана оно будет разным. Поэтому напишем формулу "elementWidth * -0.95", а умножаем на отрицательное значение потому, что это про движение влево. Соответственно в самом верху надо также создать константу, которая будет получать ширину вьюпорта, с которого зашёл пользователь для расчёта этой формулы.
// 66.9.4 Ну, и вернувшись к нашему условию в функции "moveCardOver" скажем, что если "movement" > 20, тогда x = leftSnapX (т.е. инвойс уедет до ограничителя влево). Также сделаем условие и для движения вправо, но условие будет уже < -20 и тогда элемент инвойса вернётся на своё изначальное место. А в конце мы обновляем хранилище с координатами.
// 66.10 Но у нас остался ещё досадный баг, что если дёрнуть элемент инвойса вправо, то он вылетает за пределы экрана вовсе, чтоб это поведение предотвратить напишем ещё одну функцию "updateCoordinates". И мы будем её вызывать с переданной внутрь переменной "х" в каждом из условий, обновляя хранилище.
export const swipe = (node: HTMLElement, params: SwipeProps) => {
  const elementWidth = node.clientWidth;
  let x: number;
  let startingX: number;
  let endingX: number;

  const coordinates = spring({ x: 0, y: 0 }, { stiffness: 0.2, damping: 0.4 });

  coordinates.subscribe(($coords) => {
    node.style.transform = `translate3d(${$coords.x}px, 0, 0)`;
  });

  const handleMouseDown = (event: MouseEvent) => {
    x = event.clientX;
    startingX = event.clientX;

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
  };

  const handleMouseMove = (event: MouseEvent) => {
    const dx = event.clientX - x;

    x = event.clientX;

    coordinates.update(($coords) => {
      return {
        x: $coords.x + dx,
        y: 0
      };
    });
  };

  const updateCoordinates = (x: number) => {
    coordinates.update(() => {
      return {
        x,
        y: 0
      };
    });
  };

  const moveCardOver = (endingX: number) => {
    const leftSnapX = elementWidth * -0.95;
    const rightSnapX = 0;
    const movement = startingX - endingX;

    if (movement > 20) {
      x = leftSnapX;
      updateCoordinates(x);
    }
    if (movement < -20) {
      x = rightSnapX;
      updateCoordinates(x);
    }

    coordinates.update(() => {
      return {
        x,
        y: 0
      };
    });
  };

  const handleMouseUp = (event: MouseEvent) => {
    endingX = event.clientX;
    moveCardOver(endingX);

    window.removeEventListener('mousemove', handleMouseMove);
    window.removeEventListener('mouseup', handleMouseUp);
  };

  node.addEventListener('mousedown', handleMouseDown);
  return {
    update() {},
    destroy() {
      node.removeEventListener('mousedown', handleMouseDown);
    }
  };
};
